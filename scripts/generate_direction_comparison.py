#!/usr/bin/env python3
"""Generate ANN vs. buoy wind-direction error diagnostics and visuals."""

from __future__ import annotations

import argparse
import json
import math
from pathlib import Path
from typing import Iterable

import sys

import numpy as np
import pandas as pd

sys.path.insert(0, str(Path(__file__).resolve().parents[1] / "src"))

from hf_wind_resource.stats import evaluate_direction_pairs


DEFAULT_MATCHED_DATASET = (
    Path("artifacts/processed/vilano_buoy_synced.parquet")
)
DEFAULT_OUTPUT_DIR = Path("artifacts/direction_comparison")
SUMMARY_FILENAME = "direction_metrics_summary.csv"
QUALITY_FILENAME = "direction_quality.json"
ERRORS_FILENAME = "direction_errors.parquet"
HISTOGRAM_FILENAME = "absolute_error_histogram.svg"
SCATTER_FILENAME = "direction_scatter.svg"
COVERAGE_FILENAME = "coverage_comparison.svg"
_SCATTER_SAMPLE_LIMIT = 5000


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Evaluate angular discrepancies between ANN predictions and buoy observations."
    )
    parser.add_argument(
        "--matched-dataset",
        type=Path,
        default=DEFAULT_MATCHED_DATASET,
        help="Path to the GeoParquet file generated by prepare_buoy_timeseries.py.",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=DEFAULT_OUTPUT_DIR,
        help="Directory where artefacts will be written.",
    )
    parser.add_argument(
        "--scatter-sample-limit",
        type=int,
        default=_SCATTER_SAMPLE_LIMIT,
        help="Maximum number of points to include in the scatter plot (for readability).",
    )
    return parser.parse_args()


def _normalise_range_flag(series: pd.Series) -> pd.Series:
    """Return a lowercase representation of the range flag."""

    return series.astype("string").str.lower()


def _compute_scenario_summary(
    name: str,
    result,
    *,
    scenario_total: int,
    matched_total: int,
) -> dict[str, object]:
    """Convert a DirectionErrorResult into a serialisable summary row."""

    metrics = result.metrics
    quality = result.quality
    coverage_vs_matched = (
        quality.valid_pairs / matched_total if matched_total else 0.0
    )

    def _maybe(value: float | None) -> float | None:
        if value is None:
            return None
        if math.isnan(value):
            return None
        return float(value)

    return {
        "scenario": name,
        "prefilter_pairs": scenario_total,
        "total_pairs": quality.total_pairs,
        "valid_pairs": quality.valid_pairs,
        "missing_pairs": quality.missing_pairs,
        "sentinel_pairs": quality.sentinel_pairs,
        "nonfinite_pairs": quality.nonfinite_pairs,
        "coverage_ratio": quality.coverage_ratio,
        "coverage_vs_matched": coverage_vs_matched,
        "mean_absolute_error_deg": _maybe(metrics.mean_absolute_error_deg),
        "root_mean_square_error_deg": _maybe(metrics.root_mean_square_error_deg),
        "circular_bias_deg": _maybe(metrics.circular_bias_deg),
        "absolute_error_p50_deg": _maybe(metrics.absolute_error_p50_deg),
        "absolute_error_p90_deg": _maybe(metrics.absolute_error_p90_deg),
        "absolute_error_p99_deg": _maybe(metrics.absolute_error_p99_deg),
        "max_absolute_error_deg": _maybe(metrics.max_absolute_error_deg),
    }


def _write_summary_csv(path: Path, rows: Iterable[dict[str, object]]) -> None:
    frame = pd.DataFrame(rows)
    frame.to_csv(path, index=False)


def _write_quality_json(path: Path, rows: Iterable[dict[str, object]]) -> None:
    payload = {row["scenario"]: row for row in rows}
    path.write_text(json.dumps(payload, indent=2), encoding="utf-8")


def _write_errors_parquet(path: Path, frame: pd.DataFrame) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    frame.to_parquet(path, index=False)


def _write_histogram_svg(path: Path, values: np.ndarray, *, bins: int = 36) -> None:
    width, height = 800, 420
    margin_left, margin_bottom = 70, 50
    margin_top, margin_right = 30, 20
    chart_width = width - margin_left - margin_right
    chart_height = height - margin_bottom - margin_top

    if values.size == 0:
        svg = (
            f'<svg xmlns="http://www.w3.org/2000/svg" width="{width}" height="{height}">'
            '<rect width="100%" height="100%" fill="#ffffff"/>'
            '<text x="50%" y="50%" text-anchor="middle" fill="#555555" font-size="18">'
            "No data available"
            "</text>"
            "</svg>"
        )
        path.write_text(svg, encoding="utf-8")
        return

    counts, edges = np.histogram(values, bins=bins, range=(0.0, 180.0))
    max_count = max(int(np.max(counts)), 1)

    bar_width = chart_width / bins
    y_scale = chart_height / max_count

    bars = []
    for idx, count in enumerate(counts):
        x = margin_left + idx * bar_width
        bar_height = count * y_scale
        y = margin_top + chart_height - bar_height
        bars.append(
            f'<rect x="{x:.2f}" y="{y:.2f}" width="{bar_width:.2f}" height="{bar_height:.2f}" fill="#3a7ad9"/>'
        )

    axis_lines = [
        f'<line x1="{margin_left}" y1="{margin_top + chart_height}" '
        f'x2="{margin_left + chart_width}" y2="{margin_top + chart_height}" stroke="#333333" stroke-width="1.5"/>',
        f'<line x1="{margin_left}" y1="{margin_top}" '
        f'x2="{margin_left}" y2="{margin_top + chart_height}" stroke="#333333" stroke-width="1.5"/>',
    ]

    tick_labels = []
    for angle in (0, 45, 90, 135, 180):
        x = margin_left + (angle / 180.0) * chart_width
        axis_lines.append(
            f'<line x1="{x:.2f}" y1="{margin_top + chart_height}" '
            f'x2="{x:.2f}" y2="{margin_top + chart_height + 6}" stroke="#333333" stroke-width="1"/>'
        )
        tick_labels.append(
            f'<text x="{x:.2f}" y="{margin_top + chart_height + 24}" '
            'text-anchor="middle" font-size="14" fill="#333333">'
            f'{angle}'
            "</text>"
        )

    y_ticks = []
    for fraction in (0.0, 0.25, 0.5, 0.75, 1.0):
        y_value = margin_top + chart_height - fraction * chart_height
        axis_lines.append(
            f'<line x1="{margin_left - 6}" y1="{y_value:.2f}" '
            f'x2="{margin_left}" y2="{y_value:.2f}" stroke="#333333" stroke-width="1"/>'
        )
        label_count = int(round(max_count * fraction))
        y_ticks.append(
            f'<text x="{margin_left - 10}" y="{y_value + 5:.2f}" '
            'text-anchor="end" font-size="14" fill="#333333">'
            f'{label_count}'
            "</text>"
        )

    labels = [
        f'<text x="{width / 2:.2f}" y="{height - 10}" text-anchor="middle" font-size="16" fill="#222222">'
        "Absolute angular error (degrees)"
        "</text>",
        f'<text x="{20}" y="{(margin_top + chart_height / 2):.2f}" '
        'text-anchor="middle" font-size="16" fill="#222222" transform="rotate(-90,20,'
        f'{(margin_top + chart_height / 2):.2f})">Count</text>',
        f'<text x="{width / 2:.2f}" y="22" text-anchor="middle" font-size="18" fill="#222222">'
        "ANN vs. buoy absolute angular error distribution"
        "</text>",
    ]

    svg_parts = [
        f'<svg xmlns="http://www.w3.org/2000/svg" width="{width}" height="{height}">',
        '<rect width="100%" height="100%" fill="#ffffff"/>',
        *axis_lines,
        *bars,
        *tick_labels,
        *y_ticks,
        *labels,
        "</svg>",
    ]
    path.write_text("\n".join(svg_parts), encoding="utf-8")


def _write_scatter_svg(
    path: Path,
    predicted: np.ndarray,
    observed: np.ndarray,
    *,
    sample_limit: int,
) -> None:
    width, height = 520, 520
    margin = 60
    chart_width = width - 2 * margin
    chart_height = height - 2 * margin

    values = np.column_stack((predicted, observed))
    if values.size == 0:
        svg = (
            f'<svg xmlns="http://www.w3.org/2000/svg" width="{width}" height="{height}">'
            '<rect width="100%" height="100%" fill="#ffffff"/>'
            '<text x="50%" y="50%" text-anchor="middle" fill="#555555" font-size="18">'
            "No data available"
            "</text>"
            "</svg>"
        )
        path.write_text(svg, encoding="utf-8")
        return

    if values.shape[0] > sample_limit:
        rng = np.random.default_rng(seed=42)
        indices = rng.choice(values.shape[0], size=sample_limit, replace=False)
        values = values[indices]

    ticks = [0, 90, 180, 270, 360]
    grid_lines = []
    tick_labels = []
    for angle in ticks:
        x = margin + (angle / 360.0) * chart_width
        y = margin + chart_height - (angle / 360.0) * chart_height
        grid_lines.append(
            f'<line x1="{x:.2f}" y1="{margin}" x2="{x:.2f}" y2="{margin + chart_height}" '
            'stroke="#dddddd" stroke-width="1"/>'
        )
        grid_lines.append(
            f'<line x1="{margin}" y1="{y:.2f}" x2="{margin + chart_width}" y2="{y:.2f}" '
            'stroke="#dddddd" stroke-width="1"/>'
        )
        tick_labels.append(
            f'<text x="{x:.2f}" y="{margin + chart_height + 24}" text-anchor="middle" '
            'font-size="13" fill="#333333">'
            f'{angle}'
            "</text>"
        )
        tick_labels.append(
            f'<text x="{margin - 18}" y="{y + 4:.2f}" text-anchor="end" font-size="13" fill="#333333">'
            f'{angle}'
            "</text>"
        )

    points = []
    for pred, obs in values:
        x = margin + (pred / 360.0) * chart_width
        y = margin + chart_height - (obs / 360.0) * chart_height
        points.append(
            f'<circle cx="{x:.2f}" cy="{y:.2f}" r="2.2" fill="rgba(58, 122, 217, 0.75)"/>'
        )

    axes = [
        f'<rect x="{margin}" y="{margin}" width="{chart_width}" height="{chart_height}" '
        'fill="none" stroke="#333333" stroke-width="1.5"/>'
    ]

    labels = [
        f'<text x="{width / 2:.2f}" y="{height - 16}" text-anchor="middle" font-size="16" fill="#222222">'
        "ANN predicted direction (degrees)"
        "</text>",
        f'<text x="{20}" y="{height / 2:.2f}" text-anchor="middle" font-size="16" fill="#222222" '
        f'transform="rotate(-90,20,{height / 2:.2f})">Buoy direction (degrees)</text>',
        f'<text x="{width / 2:.2f}" y="24" text-anchor="middle" font-size="18" fill="#222222">'
        "ANN vs. buoy wind direction"
        "</text>",
    ]

    svg_parts = [
        f'<svg xmlns="http://www.w3.org/2000/svg" width="{width}" height="{height}">',
        '<rect width="100%" height="100%" fill="#ffffff"/>',
        *grid_lines,
        *axes,
        *points,
        *tick_labels,
        *labels,
        "</svg>",
    ]
    path.write_text("\n".join(svg_parts), encoding="utf-8")


def _write_coverage_svg(path: Path, rows: Iterable[dict[str, object]]) -> None:
    data = list(rows)
    width, height = 480, 360
    margin_left, margin_bottom = 70, 50
    margin_top, margin_right = 30, 20
    chart_width = width - margin_left - margin_right
    chart_height = height - margin_bottom - margin_top

    bar_count = len(data)
    if bar_count == 0:
        svg = (
            f'<svg xmlns="http://www.w3.org/2000/svg" width="{width}" height="{height}">'
            '<rect width="100%" height="100%" fill="#ffffff"/>'
            '<text x="50%" y="50%" text-anchor="middle" fill="#555555" font-size="18">'
            "No scenarios available"
            "</text>"
            "</svg>"
        )
        path.write_text(svg, encoding="utf-8")
        return

    bar_width = chart_width / (bar_count * 1.5)
    bar_gap = bar_width / 2
    axis_lines = [
        f'<line x1="{margin_left}" y1="{margin_top + chart_height}" '
        f'x2="{margin_left + chart_width}" y2="{margin_top + chart_height}" stroke="#333333" stroke-width="1.5"/>',
        f'<line x1="{margin_left}" y1="{margin_top}" '
        f'x2="{margin_left}" y2="{margin_top + chart_height}" stroke="#333333" stroke-width="1.5"/>',
    ]

    y_ticks = []
    for fraction in (0.0, 0.25, 0.5, 0.75, 1.0):
        y_value = margin_top + chart_height - fraction * chart_height
        axis_lines.append(
            f'<line x1="{margin_left - 6}" y1="{y_value:.2f}" '
            f'x2="{margin_left}" y2="{y_value:.2f}" stroke="#333333" stroke-width="1"/>'
        )
        y_ticks.append(
            f'<text x="{margin_left - 10}" y="{y_value + 5:.2f}" text-anchor="end" font-size="13" fill="#333333">'
            f'{int(fraction * 100)}%'
            "</text>"
        )

    bars = []
    labels = []
    for idx, row in enumerate(data):
        coverage = float(row.get("coverage_vs_matched", 0.0))
        bar_height = coverage * chart_height
        x = margin_left + idx * (bar_width + bar_gap * 2) + bar_gap
        y = margin_top + chart_height - bar_height
        bars.append(
            f'<rect x="{x:.2f}" y="{y:.2f}" width="{bar_width:.2f}" height="{bar_height:.2f}" fill="#3a7ad9"/>'
        )
        labels.append(
            f'<text x="{x + bar_width / 2:.2f}" y="{margin_top + chart_height + 24}" '
            'text-anchor="middle" font-size="13" fill="#333333">'
            f'{row["scenario"]}'
            "</text>"
        )
        labels.append(
            f'<text x="{x + bar_width / 2:.2f}" y="{y - 6:.2f}" text-anchor="middle" font-size="13" fill="#222222">'
            f'{coverage * 100:.1f}%'
            "</text>"
        )

    title = (
        f'<text x="{width / 2:.2f}" y="22" text-anchor="middle" font-size="18" fill="#222222">'
        "Coverage after quality filtering (vs. matched pairs)"
        "</text>"
    )
    axis_labels = [
        f'<text x="{width / 2:.2f}" y="{height - 10}" text-anchor="middle" font-size="16" fill="#222222">'
        "Scenario"
        "</text>",
        f'<text x="{20}" y="{height / 2:.2f}" text-anchor="middle" font-size="16" fill="#222222" '
        f'transform="rotate(-90,20,{height / 2:.2f})">Valid coverage</text>',
    ]

    svg_parts = [
        f'<svg xmlns="http://www.w3.org/2000/svg" width="{width}" height="{height}">',
        '<rect width="100%" height="100%" fill="#ffffff"/>',
        title,
        *axis_lines,
        *bars,
        *labels,
        *y_ticks,
        *axis_labels,
        "</svg>",
    ]
    path.write_text("\n".join(svg_parts), encoding="utf-8")


def main() -> None:
    args = parse_args()

    dataset_path = args.matched_dataset.resolve()
    output_dir = args.output_dir.resolve()
    output_dir.mkdir(parents=True, exist_ok=True)

    if not dataset_path.exists():
        raise FileNotFoundError(f"Matched dataset not found: {dataset_path}")

    columns = [
        "timestamp_ann",
        "timestamp_buoy",
        "node_id",
        "pred_wind_direction",
        "pred_wind_speed",
        "range_flag",
        "range_flag_confident",
        "wind_dir",
        "wind_speed",
    ]
    frame = pd.read_parquet(dataset_path, columns=columns)
    frame = frame.reset_index(drop=True)
    frame["range_flag_normalized"] = _normalise_range_flag(frame["range_flag"])

    matched_total = len(frame)
    predicted_series = frame["pred_wind_direction"].astype("float64")
    observed_series = frame["wind_dir"].astype("float64")

    scenarios: dict[str, pd.Series] = {
        "all_pairs": frame.index,
        "confident": frame.index[frame["range_flag_confident"].fillna(False)],
        "confident_in_range": frame.index[
            frame["range_flag_confident"].fillna(False)
            & (frame["range_flag_normalized"] == "in")
        ],
    }

    scenario_rows: list[dict[str, object]] = []
    scenario_results: dict[str, object] = {}

    for name, index in scenarios.items():
        scenario_pred = predicted_series.loc[index]
        scenario_obs = observed_series.loc[index]
        result = evaluate_direction_pairs(scenario_pred, scenario_obs)
        scenario_total = len(index)
        row = _compute_scenario_summary(
            name,
            result,
            scenario_total=scenario_total,
            matched_total=matched_total,
        )
        scenario_rows.append(row)
        scenario_results[name] = result

    summary_path = output_dir / SUMMARY_FILENAME
    _write_summary_csv(summary_path, scenario_rows)

    quality_path = output_dir / QUALITY_FILENAME
    _write_quality_json(quality_path, scenario_rows)

    base_records = scenario_results["all_pairs"].records.copy()
    metadata_columns = [
        "timestamp_ann",
        "timestamp_buoy",
        "node_id",
        "range_flag",
        "range_flag_confident",
        "range_flag_normalized",
        "pred_wind_speed",
        "wind_speed",
    ]
    enriched = base_records.join(frame[metadata_columns], how="left")
    enriched = enriched.reset_index().rename(columns={"source_index": "matched_index"})
    enriched["is_confident"] = enriched["range_flag_confident"].fillna(False)
    enriched["is_confident_in_range"] = enriched["is_confident"] & (
        enriched["range_flag_normalized"] == "in"
    )

    errors_path = output_dir / ERRORS_FILENAME
    _write_errors_parquet(errors_path, enriched)

    absolute_errors = base_records["absolute_error_deg"].to_numpy()
    histogram_path = output_dir / HISTOGRAM_FILENAME
    _write_histogram_svg(histogram_path, absolute_errors)

    scatter_path = output_dir / SCATTER_FILENAME
    _write_scatter_svg(
        scatter_path,
        base_records["predicted_direction_deg"].to_numpy(),
        base_records["observed_direction_deg"].to_numpy(),
        sample_limit=args.scatter_sample_limit,
    )

    coverage_path = output_dir / COVERAGE_FILENAME
    _write_coverage_svg(coverage_path, scenario_rows)

    print("Directional comparison summary")
    print("------------------------------")
    for row in scenario_rows:
        coverage_pct = row["coverage_ratio"] * 100 if row["coverage_ratio"] is not None else 0.0
        mae = row["mean_absolute_error_deg"]
        print(
            f"{row['scenario']}: valid {row['valid_pairs']} / {row['total_pairs']} "
            f"({coverage_pct:.1f}%), MAE={mae:.2f}Â°" if mae is not None else
            f"{row['scenario']}: valid {row['valid_pairs']} / {row['total_pairs']} "
            f"({coverage_pct:.1f}%), insufficient data for metrics"
        )


if __name__ == "__main__":
    main()
